<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>radDotEnv (..\..\source\radDotEnv.pas)</bold>.</p>
<p>Generated at 9/30/2024 6:09:09 PM by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\source\radDotEnv.pas</p>
<table class="o"><tr><td>Number of lines covered<td>220<td rowspan=3 style="background: conic-gradient(#9fe098 80%, #eee 80%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>273<tr><td>Line coverage<td>80<small>.6</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>// DotEnv file (.env) support for Delphi
<tr class="nocodegen"><td>2<td>// Copyright 2024 Darian Miller, Licensed under Apache-2.0
<tr class="nocodegen"><td>3<td>// SPDX-License-Identifier: Apache-2.0
<tr class="nocodegen"><td>4<td>// More info: https://github.com/radprogrammer/rad-dotenv
<tr class="nocodegen"><td>5<td>unit radDotEnv;
<tr class="nocodegen"><td>6<td>
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>interface
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>// Compiler define option to create a singleton DotEnv variable during initialization for ease of use
<tr class="nocodegen"><td>11<td>{.$DEFINE radDotEnv_SINGLETON }
<tr class="nocodegen"><td>12<td>
<tr class="nocodegen"><td>13<td>uses
<tr class="nocodegen"><td>14<td>  System.SysUtils,
<tr class="nocodegen"><td>15<td>  System.Generics.Collections,
<tr class="nocodegen"><td>16<td>  System.Types;
<tr class="nocodegen"><td>17<td>
<tr class="nocodegen"><td>18<td>type
<tr class="nocodegen"><td>19<td>
<tr class="nocodegen"><td>20<td>  {$REGION Support Types}
<tr class="nocodegen"><td>21<td>  TKeyNameCaseOption = (
<tr class="nocodegen"><td>22<td>    AlwaysToUpperInvariant,
<tr class="nocodegen"><td>23<td>    AlwaysToUpper,
<tr class="nocodegen"><td>24<td>    UpperInvariantWindowsOtherwiseAsIs);  //Environment variables on other systems can be case sensitive, but it can get murky...
<tr class="nocodegen"><td>25<td>
<tr class="nocodegen"><td>26<td>
<tr class="nocodegen"><td>27<td>  TRetrieveOption = (
<tr class="nocodegen"><td>28<td>    /// &lt;summary&gt; Try getting variable from DotEnv values, and if not found, try getting from system environment&lt;/summary&gt;
<tr class="nocodegen"><td>29<td>    PreferDotEnv,
<tr class="nocodegen"><td>30<td>    /// &lt;summary&gt; Try getting from system environment, and if not found, try from DotEnv values&lt;/summary&gt;
<tr class="nocodegen"><td>31<td>    PreferSys,
<tr class="nocodegen"><td>32<td>    /// &lt;summary&gt; Only access system environment variable values (do not use DotEnv values)&lt;/summary&gt;
<tr class="nocodegen"><td>33<td>    /// &lt;remarks&gt; Some production systems never want to use DotEnv files and only utilize orchestrated system values/remarks&gt;
<tr class="nocodegen"><td>34<td>    OnlyFromSys,
<tr class="nocodegen"><td>35<td>    /// &lt;summary&gt; Only get variable from DotEnv values (do not access system environment variables)&lt;/summary&gt;
<tr class="nocodegen"><td>36<td>    OnlyFromDotEnv);
<tr class="nocodegen"><td>37<td>
<tr class="nocodegen"><td>38<td>
<tr class="nocodegen"><td>39<td>  TEscapeSequenceInterpolationOption = (
<tr class="nocodegen"><td>40<td>    SupportEscapesInDoubleQuotedValues,
<tr class="nocodegen"><td>41<td>    EscapeSequencesNotSupported);
<tr class="nocodegen"><td>42<td>
<tr class="nocodegen"><td>43<td>  TVariableSubstitutionOption = (
<tr class="nocodegen"><td>44<td>    SupportSubstutionInDoubleQuotedValues,
<tr class="nocodegen"><td>45<td>    VariableSubstutionNotSupported);
<tr class="nocodegen"><td>46<td>
<tr class="nocodegen"><td>47<td>  TEnvVarOptions = record
<tr class="nocodegen"><td>48<td>    RetrieveOption:TRetrieveOption;
<tr class="nocodegen"><td>49<td>    KeyNameCaseOption:TKeyNameCaseOption;
<tr class="nocodegen"><td>50<td>    EscapeSequenceInterpolationOption:TEscapeSequenceInterpolationOption;
<tr class="nocodegen"><td>51<td>    VariableSubstitutionOption:TVariableSubstitutionOption;
<tr class="nocodegen"><td>52<td>  end;
<tr class="nocodegen"><td>53<td>
<tr class="nocodegen"><td>54<td>
<tr class="nocodegen"><td>55<td>  // Note: this option is n/a when using the &quot;OnlyFromSys&quot; Retrieve Option as no need to set System Environment Variables when only source is System
<tr class="nocodegen"><td>56<td>  TSetOption = (
<tr class="nocodegen"><td>57<td>    /// &lt;summary&gt; After DotEnv file parsing is completed, set system environment variables based on DotEnv values only for system environment variables that have no value&lt;/summary&gt;
<tr class="nocodegen"><td>58<td>    /// &lt;remarks&gt; System variables take priority over DotEnv files&lt;/remarks&gt;
<tr class="nocodegen"><td>59<td>    DoNotOvewrite,
<tr class="nocodegen"><td>60<td>    /// &lt;summary&gt; After DotEnv file parsing is completed, do not set system environment variables based on DotEnv values&lt;/summary&gt;
<tr class="nocodegen"><td>61<td>    /// &lt;remarks&gt; Only retrieve values from DotEnv files&lt;/remarks&gt;
<tr class="nocodegen"><td>62<td>    NeverSet,
<tr class="nocodegen"><td>63<td>    /// &lt;summary&gt; After DotEnv file parsing is completed, always set system environment variables based on DotEnv values.&lt;/summary&gt;
<tr class="nocodegen"><td>64<td>    /// &lt;remarks&gt; DotEnv files take priority over (and replace) system variables. Useful for interop with older code that only reads system environment variables)&lt;/remarks&gt;
<tr class="nocodegen"><td>65<td>    AlwaysSet);
<tr class="nocodegen"><td>66<td>
<tr class="nocodegen"><td>67<td>
<tr class="nocodegen"><td>68<td>  TDotEnvOptions = record
<tr class="nocodegen"><td>69<td>  const
<tr class="nocodegen"><td>70<td>    defEnvFilename:string = '.env';
<tr class="nocodegen"><td>71<td>    defKeyNameCaseOption:TKeyNameCaseOption = TKeyNameCaseOption.AlwaysToUpperInvariant;
<tr class="nocodegen"><td>72<td>    defRetrieveOption:TRetrieveOption = TRetrieveOption.PreferDotEnv;
<tr class="nocodegen"><td>73<td>    defSetOption:TSetOption = TSetOption.DoNotOvewrite;
<tr class="nocodegen"><td>74<td>    defEscapeSequenceInterpolationOption = TEscapeSequenceInterpolationOption.SupportEscapesInDoubleQuotedValues;
<tr class="nocodegen"><td>75<td>    defVariableSubstitutionOption = TVariableSubstitutionOption.SupportSubstutionInDoubleQuotedValues;
<tr class="nocodegen"><td>76<td>  public
<tr class="nocodegen"><td>77<td>    EnvVarOptions:TEnvVarOptions;
<tr class="nocodegen"><td>78<td>    SetOption:TSetOption;
<tr class="nocodegen"><td>79<td>    EnvFileName:string;
<tr class="nocodegen"><td>80<td>    EnvSearchPaths:TArray&lt;string&gt;;
<tr class="nocodegen"><td>81<td>    FileEncoding:TEncoding;
<tr class="nocodegen"><td>82<td>    LogProc:TProc&lt;string&gt;;
<tr class="nocodegen"><td>83<td>    class function DefaultOptions:TDotEnvOptions; static;
<tr class="nocodegen"><td>84<td>  end;
<tr class="nocodegen"><td>85<td>  {$ENDREGION}
<tr class="nocodegen"><td>86<td>
<tr class="nocodegen"><td>87<td>
<tr class="nocodegen"><td>88<td>  iDotEnv = interface
<tr class="nocodegen"><td>89<td>    ['{23318557-DA37-4030-B393-05EBC885E84C}']
<tr class="nocodegen"><td>90<td>    function Get(const KeyName:string; const DefaultKeyValue:string = ''):string; overload;
<tr class="nocodegen"><td>91<td>    function Get(const KeyName:string; const DefaultKeyValue:string; const EnvVarOptions:TEnvVarOptions):string; overload;
<tr class="nocodegen"><td>92<td>
<tr class="nocodegen"><td>93<td>    function TryGet(const KeyName:string; out KeyValue:string):Boolean; overload;
<tr class="nocodegen"><td>94<td>    function TryGet(const KeyName:string; out KeyValue:string; const EnvVarOptions:TEnvVarOptions):Boolean; overload;
<tr class="nocodegen"><td>95<td>
<tr class="nocodegen"><td>96<td>    {$REGION Optional usage for functional style initialization}
<tr class="nocodegen"><td>97<td>    function UseKeyNameCaseOption(const KeyNameCaseOption:TKeyNameCaseOption):iDotEnv;
<tr class="nocodegen"><td>98<td>    function UseRetrieveOption(const RetrieveOption:TRetrieveOption):iDotEnv;
<tr class="nocodegen"><td>99<td>    function UseSetOption(const SetOption:TSetOption):iDotEnv;
<tr class="nocodegen"><td>100<td>    function UseEscapeSequenceInterpolationOption(const EscapeSequenceInterpolationOption:TEscapeSequenceInterpolationOption):iDotEnv;
<tr class="nocodegen"><td>101<td>    function UseVariableSubstitutionOption(const VariableSubstitutionOption:TVariableSubstitutionOption):iDotEnv;
<tr class="nocodegen"><td>102<td>    function UseEnvFileName(const EnvFileName:string):iDotEnv;
<tr class="nocodegen"><td>103<td>    function UseEnvSearchPaths(const EnvSearchPaths:TArray&lt;string&gt;):iDotEnv;
<tr class="nocodegen"><td>104<td>    function UseFileEncoding(const FileEncoding:TEncoding):iDotEnv;
<tr class="nocodegen"><td>105<td>    function UseLogProc(const LogProc:TProc&lt;string&gt;):iDotEnv;
<tr class="nocodegen"><td>106<td>    function Load:iDotEnv;
<tr class="nocodegen"><td>107<td>    function LoadFromString(const DotEnvContents:string):iDotEnv;
<tr class="nocodegen"><td>108<td>    {$ENDREGION}
<tr class="nocodegen"><td>109<td>  end;
<tr class="nocodegen"><td>110<td>
<tr class="nocodegen"><td>111<td>
<tr class="nocodegen"><td>112<td>function NewDotEnv:iDotEnv; overload;
<tr class="nocodegen"><td>113<td>function NewDotEnv(const Options:TDotEnvOptions):iDotEnv; overload;
<tr class="nocodegen"><td>114<td>
<tr class="nocodegen"><td>115<td>
<tr class="nocodegen"><td>116<td>{$IFDEF radDotEnv_SINGLETON}
<tr class="nocodegen"><td>117<td>var
<tr class="nocodegen"><td>118<td>  DotEnv:iDotEnv;
<tr class="nocodegen"><td>119<td>  {$IFEND}
<tr class="nocodegen"><td>120<td>
<tr class="nocodegen"><td>121<td>implementation
<tr class="nocodegen"><td>122<td>
<tr class="nocodegen"><td>123<td>uses
<tr class="nocodegen"><td>124<td>  System.Classes,
<tr class="nocodegen"><td>125<td>  {$IFDEF MSWINDOWS}
<tr class="nocodegen"><td>126<td>  WinAPI.Windows,
<tr class="nocodegen"><td>127<td>  {$ENDIF}
<tr class="nocodegen"><td>128<td>  {$IFDEF POSIX}
<tr class="nocodegen"><td>129<td>  Posix.Stdlib,
<tr class="nocodegen"><td>130<td>  {$ENDIF}
<tr class="nocodegen"><td>131<td>  System.IOUtils,
<tr class="nocodegen"><td>132<td>  System.RegularExpressions;
<tr class="nocodegen"><td>133<td>
<tr class="nocodegen"><td>134<td>var
<tr class="nocodegen"><td>135<td>  LoadGuard:TObject;
<tr class="nocodegen"><td>136<td>
<tr class="nocodegen"><td>137<td>type
<tr class="nocodegen"><td>138<td>  TNameValueMap = TDictionary&lt;string, string&gt;; // Add + 1 to: https://embt.atlassian.net/servicedesk/customer/portal/1/RSS-1862
<tr class="nocodegen"><td>139<td>  TStringKeyValue = TPair&lt;string, string&gt;;
<tr class="nocodegen"><td>140<td>  TDotEnvSource = (FromFile, FromString);
<tr class="nocodegen"><td>141<td>
<tr class="nocodegen"><td>142<td>
<tr class="nocodegen"><td>143<td>  TDotEnv = class(TInterfacedObject, iDotEnv)
<tr class="nocodegen"><td>144<td>  private const
<tr class="nocodegen"><td>145<td>    LogPrefix = '(dotenv) ';
<tr class="nocodegen"><td>146<td>    SingleQuotedChar = '''';
<tr class="nocodegen"><td>147<td>    DoubleQuotedChar = '&quot;';
<tr class="nocodegen"><td>148<td>    EscapeChar = '\';
<tr class="nocodegen"><td>149<td>    KeyNameRegexPattern = '([a-zA-Z_]+[a-zA-Z0-9_]*)';
<tr class="nocodegen"><td>150<td>    DefaultValueRegex = '-([^}]*)';
<tr class="nocodegen"><td>151<td>  strict private
<tr class="nocodegen"><td>152<td>    fMap:TNameValueMap;
<tr class="nocodegen"><td>153<td>    fOptions:TDotEnvOptions;
<tr class="nocodegen"><td>154<td>    procedure EnsureLoaded(const DotEnvSource:TDotEnvSource; const Contents:string='');
<tr class="nocodegen"><td>155<td>    procedure GuardedSearchFiles;
<tr class="nocodegen"><td>156<td>    procedure GuardedSetSystemEnvironmentVariables;
<tr class="nocodegen"><td>157<td>    procedure GuardedParseDotEnvFileContents(const Contents:string);
<tr class="nocodegen"><td>158<td>  strict protected
<tr class="nocodegen"><td>159<td>    procedure Log(const msg:string);
<tr class="nocodegen"><td>160<td>
<tr class="nocodegen"><td>161<td>    procedure AddKeyPair(const KeyName:string; const KeyValue:string; const WhichQuotedValue:Char=#0);
<tr class="nocodegen"><td>162<td>    function FormattedKeyName(const KeyName:string; const KeyNameCaseOption:TKeyNameCaseOption):string;
<tr class="nocodegen"><td>163<td>
<tr class="nocodegen"><td>164<td>    function TryGetFromDotEnv(const StdKeyName:string; out KeyValue:string):Boolean;
<tr class="nocodegen"><td>165<td>    function TryGetFromSys(const StdKeyName:string; out KeyValue:string):Boolean;
<tr class="nocodegen"><td>166<td>  public
<tr class="nocodegen"><td>167<td>    constructor Create; overload;
<tr class="nocodegen"><td>168<td>    constructor Create(const Options:TDotEnvOptions); overload;
<tr class="nocodegen"><td>169<td>    destructor Destroy; override;
<tr class="nocodegen"><td>170<td>
<tr class="nocodegen"><td>171<td>    function Get(const KeyName:string; const DefaultKeyValue:string = ''):string; overload;
<tr class="nocodegen"><td>172<td>    function Get(const KeyName:string; const DefaultKeyValue:string; const EnvVarOptions:TEnvVarOptions):string; overload;
<tr class="nocodegen"><td>173<td>
<tr class="nocodegen"><td>174<td>    function TryGet(const KeyName:string; out KeyValue:string):Boolean; overload;
<tr class="nocodegen"><td>175<td>    function TryGet(const KeyName:string; out KeyValue:string; const EnvVarOptions:TEnvVarOptions):Boolean; overload;
<tr class="nocodegen"><td>176<td>
<tr class="nocodegen"><td>177<td>    {$REGION Optional usage for functional style initialization}
<tr class="nocodegen"><td>178<td>    function UseKeyNameCaseOption(const KeyNameCaseOption:TKeyNameCaseOption):iDotEnv;
<tr class="nocodegen"><td>179<td>    function UseRetrieveOption(const RetrieveOption:TRetrieveOption):iDotEnv;
<tr class="nocodegen"><td>180<td>    function UseSetOption(const SetOption:TSetOption):iDotEnv;
<tr class="nocodegen"><td>181<td>    function UseEscapeSequenceInterpolationOption(const EscapeSequenceInterpolationOption:TEscapeSequenceInterpolationOption):iDotEnv;
<tr class="nocodegen"><td>182<td>    function UseVariableSubstitutionOption(const VariableSubstitutionOption:TVariableSubstitutionOption):iDotEnv;
<tr class="nocodegen"><td>183<td>    function UseEnvFileName(const EnvFileName:string):iDotEnv;
<tr class="nocodegen"><td>184<td>    function UseEnvSearchPaths(const EnvSearchPaths:TArray&lt;string&gt;):iDotEnv;
<tr class="nocodegen"><td>185<td>    function UseLogProc(const LogProc:TProc&lt;string&gt;):iDotEnv;
<tr class="nocodegen"><td>186<td>    function UseFileEncoding(const FileEncoding:TEncoding):iDotEnv;
<tr class="nocodegen"><td>187<td>    function Load:iDotEnv;
<tr class="nocodegen"><td>188<td>    function LoadFromString(const DotEnvContents:string):iDotEnv;
<tr class="nocodegen"><td>189<td>    {$ENDREGION}
<tr class="nocodegen"><td>190<td>  end;
<tr class="nocodegen"><td>191<td>
<tr class="nocodegen"><td>192<td>
<tr class="nocodegen"><td>193<td>function NewDotEnv:iDotEnv;
<tr class="covered"><td>194<td>begin
<tr class="covered"><td>195<td>  Result := NewDotEnv(TDotEnvOptions.DefaultOptions);
<tr class="covered"><td>196<td>end;
<tr class="nocodegen"><td>197<td>
<tr class="nocodegen"><td>198<td>
<tr class="nocodegen"><td>199<td>function NewDotEnv(const Options:TDotEnvOptions):iDotEnv;
<tr class="covered"><td>200<td>begin
<tr class="covered"><td>201<td>  Result := TDotEnv.Create(Options);
<tr class="covered"><td>202<td>end;
<tr class="nocodegen"><td>203<td>
<tr class="nocodegen"><td>204<td>
<tr class="nocodegen"><td>205<td>class function TDotEnvOptions.DefaultOptions:TDotEnvOptions;
<tr class="covered"><td>206<td>begin
<tr class="covered"><td>207<td>  Result := Default(TDotEnvOptions);
<tr class="covered"><td>208<td>  Result.EnvVarOptions.KeyNameCaseOption := defKeyNameCaseOption;
<tr class="covered"><td>209<td>  Result.EnvVarOptions.RetrieveOption := defRetrieveOption;
<tr class="covered"><td>210<td>  Result.EnvVarOptions.EscapeSequenceInterpolationOption := defEscapeSequenceInterpolationOption;
<tr class="covered"><td>211<td>  Result.EnvVarOptions.VariableSubstitutionOption := defVariableSubstitutionOption;
<tr class="covered"><td>212<td>  Result.SetOption := defSetOption;
<tr class="covered"><td>213<td>  Result.EnvFileName := defEnvFilename;
<tr class="covered"><td>214<td>  Result.EnvSearchPaths := [ExtractFilePath(ParamStr(0))]; // toreview: ParamStr(0) seems more generally appropriate than GetModuleName(HInstance)
<tr class="covered"><td>215<td>  Result.FileEncoding := TEncoding.UTF8;
<tr class="covered"><td>216<td>  Result.LogProc := nil;
<tr class="covered"><td>217<td>end;
<tr class="nocodegen"><td>218<td>
<tr class="nocodegen"><td>219<td>
<tr class="nocodegen"><td>220<td>constructor TDotEnv.Create;
<tr class="notcovered"><td>221<td>begin
<tr class="notcovered"><td>222<td>  inherited;
<tr class="notcovered"><td>223<td>  Create(TDotEnvOptions.DefaultOptions);
<tr class="notcovered"><td>224<td>end;
<tr class="nocodegen"><td>225<td>
<tr class="nocodegen"><td>226<td>
<tr class="nocodegen"><td>227<td>constructor TDotEnv.Create(const Options:TDotEnvOptions);
<tr class="covered"><td>228<td>begin
<tr class="covered"><td>229<td>  inherited Create;
<tr class="covered"><td>230<td>  fOptions := Options;
<tr class="covered"><td>231<td>  fMap := nil;
<tr class="covered"><td>232<td>end;
<tr class="nocodegen"><td>233<td>
<tr class="nocodegen"><td>234<td>
<tr class="nocodegen"><td>235<td>destructor TDotEnv.Destroy;
<tr class="covered"><td>236<td>begin
<tr class="covered"><td>237<td>  fMap.Free;
<tr class="covered"><td>238<td>  inherited;
<tr class="covered"><td>239<td>end;
<tr class="nocodegen"><td>240<td>
<tr class="nocodegen"><td>241<td>
<tr class="nocodegen"><td>242<td>procedure TDotEnv.Log(const msg:string);
<tr class="notcovered"><td>243<td>begin
<tr class="notcovered"><td>244<td>  if Assigned(fOptions.LogProc) then
<tr class="nocodegen"><td>245<td>  begin
<tr class="notcovered"><td>246<td>    fOptions.LogProc(LogPrefix + msg);
<tr class="nocodegen"><td>247<td>  end;
<tr class="notcovered"><td>248<td>end;
<tr class="nocodegen"><td>249<td>
<tr class="nocodegen"><td>250<td>
<tr class="nocodegen"><td>251<td>function TDotEnv.UseKeyNameCaseOption(const KeyNameCaseOption:TKeyNameCaseOption):iDotEnv;
<tr class="notcovered"><td>252<td>begin
<tr class="notcovered"><td>253<td>  fOptions.EnvVarOptions.KeyNameCaseOption := KeyNameCaseOption;
<tr class="notcovered"><td>254<td>  Result := self;
<tr class="notcovered"><td>255<td>end;
<tr class="nocodegen"><td>256<td>
<tr class="nocodegen"><td>257<td>
<tr class="nocodegen"><td>258<td>function TDotEnv.UseRetrieveOption(const RetrieveOption:TRetrieveOption):iDotEnv;
<tr class="covered"><td>259<td>begin
<tr class="covered"><td>260<td>  fOptions.EnvVarOptions.RetrieveOption := RetrieveOption;
<tr class="covered"><td>261<td>  Result := self;
<tr class="covered"><td>262<td>end;
<tr class="nocodegen"><td>263<td>
<tr class="nocodegen"><td>264<td>
<tr class="nocodegen"><td>265<td>function TDotEnv.UseSetOption(const SetOption:TSetOption):iDotEnv;
<tr class="covered"><td>266<td>begin
<tr class="covered"><td>267<td>  fOptions.SetOption := SetOption;
<tr class="covered"><td>268<td>  Result := self;
<tr class="covered"><td>269<td>end;
<tr class="nocodegen"><td>270<td>
<tr class="nocodegen"><td>271<td>
<tr class="nocodegen"><td>272<td>function TDotEnv.UseEscapeSequenceInterpolationOption(const EscapeSequenceInterpolationOption:TEscapeSequenceInterpolationOption):iDotEnv;
<tr class="covered"><td>273<td>begin
<tr class="covered"><td>274<td>  fOptions.EnvVarOptions.EscapeSequenceInterpolationOption := EscapeSequenceInterpolationOption;
<tr class="covered"><td>275<td>  Result := self;
<tr class="covered"><td>276<td>end;
<tr class="nocodegen"><td>277<td>
<tr class="nocodegen"><td>278<td>
<tr class="nocodegen"><td>279<td>function TDotEnv.UseVariableSubstitutionOption(const VariableSubstitutionOption:TVariableSubstitutionOption):iDotEnv;
<tr class="covered"><td>280<td>begin
<tr class="covered"><td>281<td>  fOptions.EnvVarOptions.VariableSubstitutionOption := VariableSubstitutionOption;
<tr class="covered"><td>282<td>  Result := self;
<tr class="covered"><td>283<td>end;
<tr class="nocodegen"><td>284<td>
<tr class="nocodegen"><td>285<td>
<tr class="nocodegen"><td>286<td>function TDotEnv.UseEnvFileName(const EnvFileName:string):iDotEnv;
<tr class="covered"><td>287<td>begin
<tr class="covered"><td>288<td>  fOptions.EnvFileName := EnvFileName;
<tr class="covered"><td>289<td>  Result := self;
<tr class="covered"><td>290<td>end;
<tr class="nocodegen"><td>291<td>
<tr class="nocodegen"><td>292<td>
<tr class="nocodegen"><td>293<td>function TDotEnv.UseEnvSearchPaths(const EnvSearchPaths:TArray&lt;string&gt;):iDotEnv;
<tr class="notcovered"><td>294<td>begin
<tr class="notcovered"><td>295<td>  fOptions.EnvSearchPaths := EnvSearchPaths;
<tr class="notcovered"><td>296<td>  Result := self;
<tr class="notcovered"><td>297<td>end;
<tr class="nocodegen"><td>298<td>
<tr class="nocodegen"><td>299<td>
<tr class="nocodegen"><td>300<td>function TDotEnv.UseFileEncoding(const FileEncoding:TEncoding):iDotEnv;
<tr class="notcovered"><td>301<td>begin
<tr class="notcovered"><td>302<td>  fOptions.FileEncoding := FileEncoding;
<tr class="notcovered"><td>303<td>  Result := self;
<tr class="notcovered"><td>304<td>end;
<tr class="nocodegen"><td>305<td>
<tr class="nocodegen"><td>306<td>
<tr class="nocodegen"><td>307<td>function TDotEnv.UseLogProc(const LogProc:TProc&lt;string&gt;):iDotEnv;
<tr class="notcovered"><td>308<td>begin
<tr class="notcovered"><td>309<td>  fOptions.LogProc := LogProc;
<tr class="notcovered"><td>310<td>  Result := self;
<tr class="notcovered"><td>311<td>end;
<tr class="nocodegen"><td>312<td>
<tr class="nocodegen"><td>313<td>
<tr class="nocodegen"><td>314<td>function TDotEnv.Load:iDotEnv;
<tr class="covered"><td>315<td>begin
<tr class="covered"><td>316<td>  self.EnsureLoaded(TDotEnvSource.FromFile);
<tr class="covered"><td>317<td>  Result := self;
<tr class="covered"><td>318<td>end;
<tr class="nocodegen"><td>319<td>
<tr class="nocodegen"><td>320<td>function TDotEnv.LoadFromString(const DotEnvContents:string):iDotEnv;
<tr class="covered"><td>321<td>begin
<tr class="covered"><td>322<td>  self.EnsureLoaded(TDotEnvSource.FromString, DotEnvContents);
<tr class="covered"><td>323<td>  Result := Self;
<tr class="covered"><td>324<td>end;
<tr class="nocodegen"><td>325<td>
<tr class="nocodegen"><td>326<td>
<tr class="nocodegen"><td>327<td>function TDotEnv.FormattedKeyName(const KeyName:string; const KeyNameCaseOption:TKeyNameCaseOption):string;
<tr class="covered"><td>328<td>begin
<tr class="covered"><td>329<td>  if KeyNameCaseOption = TKeyNameCaseOption.AlwaysToUpperInvariant then
<tr class="nocodegen"><td>330<td>  begin
<tr class="covered"><td>331<td>    Result := KeyName.Trim.ToUpperInvariant;
<tr class="nocodegen"><td>332<td>  end
<tr class="notcovered"><td>333<td>  else if KeyNameCaseOption = TKeyNameCaseOption.AlwaysToUpper then
<tr class="nocodegen"><td>334<td>  begin
<tr class="notcovered"><td>335<td>    Result := KeyName.Trim.ToUpper;
<tr class="nocodegen"><td>336<td>  end
<tr class="nocodegen"><td>337<td>  else { UpperInvariantWindowsOtherwiseAsIs }
<tr class="nocodegen"><td>338<td>  begin
<tr class="notcovered"><td>339<td>    Assert(KeyNameCaseOption = TKeyNameCaseOption.UpperInvariantWindowsOtherwiseAsIs, Format('Unknown KeyNameCaseOption (%d) in TDotEnv.FormattedKeyName', [Ord(KeyNameCaseOption)]));
<tr class="nocodegen"><td>340<td>    {$IFDEF MSWINDOWS}
<tr class="notcovered"><td>341<td>    Result := KeyName.Trim.ToUpperInvariant;
<tr class="nocodegen"><td>342<td>    {$ELSE}
<tr class="nocodegen"><td>343<td>    Result := KeyName.Trim;
<tr class="nocodegen"><td>344<td>    {$IFEND}
<tr class="nocodegen"><td>345<td>  end;
<tr class="covered"><td>346<td>end;
<tr class="nocodegen"><td>347<td>
<tr class="nocodegen"><td>348<td>
<tr class="nocodegen"><td>349<td>procedure TDotEnv.AddKeyPair(const KeyName:string; const KeyValue:string; const WhichQuotedValue:Char=#0);
<tr class="nocodegen"><td>350<td>
<tr class="nocodegen"><td>351<td>
<tr class="nocodegen"><td>352<td>  function ResolveEmbeddedVariables(const Input:string):string;
<tr class="nocodegen"><td>353<td>  var
<tr class="nocodegen"><td>354<td>    Regex:TRegEx;
<tr class="nocodegen"><td>355<td>    Match:TMatch;
<tr class="nocodegen"><td>356<td>    VarName, ResolvedValue, DefaultValue:string;
<tr class="covered"><td>357<td>  begin
<tr class="covered"><td>358<td>    Result := Input;
<tr class="nocodegen"><td>359<td>
<tr class="covered"><td>360<td>    RegEx := TRegEx.Create('\$\{' + TDotEnv.KeyNameRegexPattern + '\}' + '|' +
<tr class="nocodegen"><td>361<td>                           '\$\{' + TDotEnv.KeyNameRegexPattern + DefaultValueRegex + '\}');
<tr class="covered"><td>362<td>    Match := Regex.Match(Result);
<tr class="covered"><td>363<td>    while Match.Success do
<tr class="nocodegen"><td>364<td>    begin
<tr class="nocodegen"><td>365<td>
<tr class="covered"><td>366<td>      VarName := Match.Groups[1].Value;
<tr class="covered"><td>367<td>      DefaultValue := '';
<tr class="covered"><td>368<td>      if (Match.Groups[1].Success) and (Match.Groups.Count &gt; 2) and Match.Groups[3].Success then //${KEY-default} found, extract default value
<tr class="nocodegen"><td>369<td>      begin
<tr class="covered"><td>370<td>        DefaultValue := Match.Groups[3].Value;
<tr class="nocodegen"><td>371<td>      end;
<tr class="nocodegen"><td>372<td>
<tr class="covered"><td>373<td>      if not TryGet(VarName, ResolvedValue) then
<tr class="covered"><td>374<td>        ResolvedValue := DefaultValue;
<tr class="nocodegen"><td>375<td>
<tr class="covered"><td>376<td>      Result := StringReplace(Result, Match.Value, ResolvedValue, []);
<tr class="covered"><td>377<td>      Match := Match.NextMatch;
<tr class="nocodegen"><td>378<td>    end;
<tr class="covered"><td>379<td>  end;
<tr class="nocodegen"><td>380<td>
<tr class="nocodegen"><td>381<td>  function UnescapeString(const Input:string):string;
<tr class="nocodegen"><td>382<td>  var
<tr class="nocodegen"><td>383<td>    Src, Dst:PChar;
<tr class="nocodegen"><td>384<td>    Output:string;
<tr class="nocodegen"><td>385<td>    Ch:Char;
<tr class="nocodegen"><td>386<td>    Len:Integer;
<tr class="nocodegen"><td>387<td>
<tr class="nocodegen"><td>388<td>    function GetEscapedChar(var P:PChar):Char;
<tr class="covered"><td>389<td>    begin
<tr class="covered"><td>390<td>      Inc(P); // Skip the backslash
<tr class="covered"><td>391<td>      case P^ of
<tr class="nocodegen"><td>392<td>        'n': // Line feed
<tr class="covered"><td>393<td>          Result := #10;
<tr class="nocodegen"><td>394<td>        't': // Tab
<tr class="covered"><td>395<td>          Result := #9;
<tr class="nocodegen"><td>396<td>        'r': // Carriage return
<tr class="covered"><td>397<td>          Result := #13;
<tr class="nocodegen"><td>398<td>        EscapeChar:
<tr class="covered"><td>399<td>          Result := EscapeChar;
<tr class="nocodegen"><td>400<td>        '&quot;':
<tr class="covered"><td>401<td>          Result := '&quot;';
<tr class="nocodegen"><td>402<td>        '''':
<tr class="covered"><td>403<td>          Result := '''';
<tr class="nocodegen"><td>404<td>      else
<tr class="covered"><td>405<td>        Result := P^;  //unknown, as-is
<tr class="nocodegen"><td>406<td>      end;
<tr class="covered"><td>407<td>      Inc(P);
<tr class="covered"><td>408<td>    end;
<tr class="nocodegen"><td>409<td>
<tr class="nocodegen"><td>410<td>
<tr class="covered"><td>411<td>  begin
<tr class="covered"><td>412<td>    Len := Length(Input);
<tr class="covered"><td>413<td>    SetLength(Output, Len);
<tr class="covered"><td>414<td>    Src := PChar(Input);
<tr class="covered"><td>415<td>    Dst := PChar(Output);
<tr class="nocodegen"><td>416<td>
<tr class="covered"><td>417<td>    while Src^ &lt;&gt; #0 do
<tr class="nocodegen"><td>418<td>    begin
<tr class="covered"><td>419<td>      if Src^ = EscapeChar then
<tr class="nocodegen"><td>420<td>      begin
<tr class="covered"><td>421<td>        Ch := GetEscapedChar(Src);
<tr class="covered"><td>422<td>        Dst^ := Ch;
<tr class="nocodegen"><td>423<td>      end
<tr class="nocodegen"><td>424<td>      else
<tr class="nocodegen"><td>425<td>      begin
<tr class="covered"><td>426<td>        Dst^ := Src^;
<tr class="covered"><td>427<td>        Inc(Src);
<tr class="nocodegen"><td>428<td>      end;
<tr class="covered"><td>429<td>      Inc(Dst);
<tr class="nocodegen"><td>430<td>    end;
<tr class="nocodegen"><td>431<td>
<tr class="covered"><td>432<td>    SetLength(Output, Dst - PChar(Output));
<tr class="covered"><td>433<td>    Result := Output;
<tr class="covered"><td>434<td>  end;
<tr class="nocodegen"><td>435<td>
<tr class="nocodegen"><td>436<td>
<tr class="nocodegen"><td>437<td>var
<tr class="nocodegen"><td>438<td>  InterpolatedValue:string;
<tr class="covered"><td>439<td>begin
<tr class="covered"><td>440<td>  if WhichQuotedValue = #0 then
<tr class="nocodegen"><td>441<td>  begin
<tr class="covered"><td>442<td>    InterpolatedValue := KeyValue.Trim;  //Unquoted values are always trimmed
<tr class="nocodegen"><td>443<td>  end
<tr class="nocodegen"><td>444<td>  else
<tr class="nocodegen"><td>445<td>  begin
<tr class="covered"><td>446<td>    InterpolatedValue := KeyValue;  //Quoted values keep spacing  Key=&quot; value &quot;
<tr class="nocodegen"><td>447<td>  end;
<tr class="nocodegen"><td>448<td>
<tr class="covered"><td>449<td>  if not (fOptions.EnvVarOptions.EscapeSequenceInterpolationOption = TEscapeSequenceInterpolationOption.EscapeSequencesNotSupported) then
<tr class="nocodegen"><td>450<td>  begin
<tr class="covered"><td>451<td>    if (WhichQuotedValue = TDotEnv.DoubleQuotedChar) and (fOptions.EnvVarOptions.EscapeSequenceInterpolationOption = TEscapeSequenceInterpolationOption.SupportEscapesInDoubleQuotedValues) then
<tr class="nocodegen"><td>452<td>    begin
<tr class="covered"><td>453<td>      InterpolatedValue := UnescapeString(InterpolatedValue);
<tr class="nocodegen"><td>454<td>    end;
<tr class="nocodegen"><td>455<td>  end;
<tr class="nocodegen"><td>456<td>
<tr class="covered"><td>457<td>  if not (fOptions.EnvVarOptions.VariableSubstitutionOption = TVariableSubstitutionOption.VariableSubstutionNotSupported) then
<tr class="nocodegen"><td>458<td>  begin
<tr class="covered"><td>459<td>    if (WhichQuotedValue = TDotEnv.DoubleQuotedChar) and (fOptions.EnvVarOptions.VariableSubstitutionOption = TVariableSubstitutionOption.SupportSubstutionInDoubleQuotedValues) then
<tr class="nocodegen"><td>460<td>    begin
<tr class="covered"><td>461<td>      InterpolatedValue := ResolveEmbeddedVariables(InterpolatedValue);
<tr class="nocodegen"><td>462<td>    end;
<tr class="nocodegen"><td>463<td>  end;
<tr class="nocodegen"><td>464<td>
<tr class="covered"><td>465<td>  fMap.AddOrSetValue(FormattedKeyName(KeyName, fOptions.EnvVarOptions.KeyNameCaseOption), InterpolatedValue);
<tr class="covered"><td>466<td>end;
<tr class="nocodegen"><td>467<td>
<tr class="nocodegen"><td>468<td>
<tr class="nocodegen"><td>469<td>function TDotEnv.Get(const KeyName:string; const DefaultKeyValue:string = ''):string;
<tr class="covered"><td>470<td>begin
<tr class="covered"><td>471<td>  Result := Get(KeyName, DefaultKeyValue, fOptions.EnvVarOptions);
<tr class="covered"><td>472<td>end;
<tr class="nocodegen"><td>473<td>
<tr class="nocodegen"><td>474<td>
<tr class="nocodegen"><td>475<td>function TDotEnv.Get(const KeyName:string; const DefaultKeyValue:string; const EnvVarOptions:TEnvVarOptions):string;
<tr class="covered"><td>476<td>begin
<tr class="covered"><td>477<td>  if not TryGet(KeyName, Result, EnvVarOptions) then
<tr class="nocodegen"><td>478<td>  begin
<tr class="covered"><td>479<td>    Result := DefaultKeyValue;
<tr class="nocodegen"><td>480<td>  end;
<tr class="covered"><td>481<td>end;
<tr class="nocodegen"><td>482<td>
<tr class="nocodegen"><td>483<td>
<tr class="nocodegen"><td>484<td>function TDotEnv.TryGet(const KeyName:string; out KeyValue:string):Boolean;
<tr class="covered"><td>485<td>begin
<tr class="covered"><td>486<td>  Result := TryGet(KeyName, KeyValue, fOptions.EnvVarOptions);
<tr class="covered"><td>487<td>end;
<tr class="nocodegen"><td>488<td>
<tr class="nocodegen"><td>489<td>
<tr class="nocodegen"><td>490<td>function TDotEnv.TryGet(const KeyName:string; out KeyValue:string; const EnvVarOptions:TEnvVarOptions):Boolean;
<tr class="nocodegen"><td>491<td>var
<tr class="nocodegen"><td>492<td>  StdKeyName:string;
<tr class="covered"><td>493<td>begin
<tr class="covered"><td>494<td>  if not Assigned(fMap) then
<tr class="nocodegen"><td>495<td>  begin
<tr class="notcovered"><td>496<td>    EnsureLoaded(TDotEnvSource.FromFile);
<tr class="nocodegen"><td>497<td>  end;
<tr class="nocodegen"><td>498<td>
<tr class="covered"><td>499<td>  StdKeyName := FormattedKeyName(KeyName, EnvVarOptions.KeyNameCaseOption);
<tr class="nocodegen"><td>500<td>
<tr class="covered"><td>501<td>  case EnvVarOptions.RetrieveOption of
<tr class="nocodegen"><td>502<td>    TRetrieveOption.OnlyFromDotEnv:
<tr class="covered"><td>503<td>      Result := TryGetFromDotEnv(StdKeyName, KeyValue);
<tr class="nocodegen"><td>504<td>    TRetrieveOption.OnlyFromSys:
<tr class="notcovered"><td>505<td>      Result := TryGetFromSys(StdKeyName, KeyValue);
<tr class="nocodegen"><td>506<td>    TRetrieveOption.PreferSys:
<tr class="notcovered"><td>507<td>      Result := TryGetFromSys(StdKeyName, KeyValue) or TryGetFromDotEnv(StdKeyName, KeyValue);
<tr class="nocodegen"><td>508<td>  else { PreferDotEnv }
<tr class="notcovered"><td>509<td>    Assert(EnvVarOptions.RetrieveOption = TRetrieveOption.PreferDotEnv, Format('Unknown RetrieveOption (%d) in TDotEnv.TryGet', [Ord(EnvVarOptions.RetrieveOption)]));
<tr class="notcovered"><td>510<td>    Result := TryGetFromDotEnv(StdKeyName, KeyValue) or TryGetFromSys(StdKeyName, KeyValue);
<tr class="nocodegen"><td>511<td>  end;
<tr class="nocodegen"><td>512<td>
<tr class="covered"><td>513<td>end;
<tr class="nocodegen"><td>514<td>
<tr class="nocodegen"><td>515<td>
<tr class="nocodegen"><td>516<td>function TDotEnv.TryGetFromDotEnv(const StdKeyName:string; out KeyValue:string):Boolean;
<tr class="covered"><td>517<td>begin
<tr class="covered"><td>518<td>  Result := fMap.TryGetValue(StdKeyName, KeyValue);
<tr class="covered"><td>519<td>end;
<tr class="nocodegen"><td>520<td>
<tr class="nocodegen"><td>521<td>
<tr class="nocodegen"><td>522<td>function TDotEnv.TryGetFromSys(const StdKeyName:string; out KeyValue:string):Boolean;
<tr class="notcovered"><td>523<td>begin
<tr class="notcovered"><td>524<td>  KeyValue := GetEnvironmentVariable(StdKeyName);
<tr class="notcovered"><td>525<td>  Result := not KeyValue.Trim.IsEmpty;
<tr class="notcovered"><td>526<td>end;
<tr class="nocodegen"><td>527<td>
<tr class="nocodegen"><td>528<td>
<tr class="nocodegen"><td>529<td>procedure TDotEnv.EnsureLoaded(const DotEnvSource:TDotEnvSource; const Contents:string='');
<tr class="nocodegen"><td>530<td>
<tr class="covered"><td>531<td>begin
<tr class="covered"><td>532<td>  TMonitor.Enter(LoadGuard);
<tr class="covered"><td>533<td>  try
<tr class="covered"><td>534<td>    if not Assigned(fMap) then
<tr class="nocodegen"><td>535<td>    begin
<tr class="covered"><td>536<td>      fMap := TNameValueMap.Create;
<tr class="nocodegen"><td>537<td>    end;
<tr class="nocodegen"><td>538<td>
<tr class="covered"><td>539<td>    if DotEnvSource = TDotEnvSource.FromFile then
<tr class="nocodegen"><td>540<td>    begin
<tr class="covered"><td>541<td>      GuardedSearchFiles;
<tr class="nocodegen"><td>542<td>    end
<tr class="nocodegen"><td>543<td>    else
<tr class="nocodegen"><td>544<td>    begin
<tr class="covered"><td>545<td>      GuardedParseDotEnvFileContents(Contents);
<tr class="nocodegen"><td>546<td>    end;
<tr class="nocodegen"><td>547<td>
<tr class="covered"><td>548<td>    GuardedSetSystemEnvironmentVariables;
<tr class="nocodegen"><td>549<td>  finally
<tr class="covered"><td>550<td>    TMonitor.Exit(LoadGuard);
<tr class="nocodegen"><td>551<td>  end;
<tr class="covered"><td>552<td>end;
<tr class="nocodegen"><td>553<td>
<tr class="nocodegen"><td>554<td>
<tr class="nocodegen"><td>555<td>procedure TDotEnv.GuardedSearchFiles;
<tr class="nocodegen"><td>556<td>var
<tr class="nocodegen"><td>557<td>  SearchPath:string;
<tr class="nocodegen"><td>558<td>  FullPathName:string;
<tr class="nocodegen"><td>559<td>  Contents:string;
<tr class="covered"><td>560<td>begin
<tr class="covered"><td>561<td>  for SearchPath in fOptions.EnvSearchPaths do
<tr class="nocodegen"><td>562<td>  begin
<tr class="covered"><td>563<td>    FullPathName := TPath.Combine(SearchPath, fOptions.EnvFileName);
<tr class="covered"><td>564<td>    if TFile.Exists(FullPathName) then
<tr class="nocodegen"><td>565<td>    begin
<tr class="covered"><td>566<td>      try
<tr class="covered"><td>567<td>        Contents := TFile.ReadAllText(FullPathName, fOptions.FileEncoding);
<tr class="notcovered"><td>568<td>      except on E: Exception do
<tr class="nocodegen"><td>569<td>        begin
<tr class="notcovered"><td>570<td>          Log(Format('Failed to load DotEnv file %s, exception: %s', [FullPathName, E.Message]));
<tr class="notcovered"><td>571<td>          Exit;
<tr class="nocodegen"><td>572<td>        end;
<tr class="nocodegen"><td>573<td>      end;
<tr class="covered"><td>574<td>      GuardedParseDotEnvFileContents(Contents);
<tr class="nocodegen"><td>575<td>    end;
<tr class="covered"><td>576<td>  end;
<tr class="covered"><td>577<td>end;
<tr class="nocodegen"><td>578<td>
<tr class="nocodegen"><td>579<td>
<tr class="nocodegen"><td>580<td>procedure XPlatSetEnvironmentVariable(const AName, AValue:string);
<tr class="nocodegen"><td>581<td>{$IFDEF POSIX}
<tr class="nocodegen"><td>582<td>var
<tr class="nocodegen"><td>583<td>  s1, s2:RawByteString;
<tr class="nocodegen"><td>584<td>  {$ENDIF}
<tr class="notcovered"><td>585<td>begin
<tr class="nocodegen"><td>586<td>  {$IFDEF MSWINDOWS}
<tr class="notcovered"><td>587<td>  SetEnvironmentVariable(PChar(AName), PChar(AValue));
<tr class="nocodegen"><td>588<td>  {$ENDIF}
<tr class="nocodegen"><td>589<td>  {$IFDEF POSIX}
<tr class="nocodegen"><td>590<td>  s1 := TFDEncoder.Enco(AName, ecUTF8);
<tr class="nocodegen"><td>591<td>  s2 := TFDEncoder.Enco(AValue, ecUTF8);
<tr class="nocodegen"><td>592<td>  setenv(MarshaledAString(PByte(s1)), MarshaledAString(PByte(s2)), 1);
<tr class="nocodegen"><td>593<td>  {$ENDIF}
<tr class="notcovered"><td>594<td>end;
<tr class="nocodegen"><td>595<td>
<tr class="nocodegen"><td>596<td>
<tr class="nocodegen"><td>597<td>procedure TDotEnv.GuardedSetSystemEnvironmentVariables;
<tr class="nocodegen"><td>598<td>var
<tr class="nocodegen"><td>599<td>  KeyPair:TStringKeyValue;
<tr class="nocodegen"><td>600<td>  KeyPairArray:TArray&lt;TStringKeyValue&gt;;
<tr class="nocodegen"><td>601<td>  SetVar:Boolean;
<tr class="nocodegen"><td>602<td>  CurrentValue:string;
<tr class="covered"><td>603<td>begin
<tr class="covered"><td>604<td>  if fOptions.SetOption = TSetOption.NeverSet then
<tr class="nocodegen"><td>605<td>    Exit;
<tr class="nocodegen"><td>606<td>
<tr class="notcovered"><td>607<td>  KeyPairArray := fMap.ToArray;
<tr class="notcovered"><td>608<td>  for KeyPair in KeyPairArray do
<tr class="nocodegen"><td>609<td>  begin
<tr class="notcovered"><td>610<td>    SetVar := True; //TSetOption.AlwaysSet
<tr class="notcovered"><td>611<td>    if fOptions.SetOption = TSetOption.DoNotOvewrite then
<tr class="nocodegen"><td>612<td>    begin
<tr class="notcovered"><td>613<td>      CurrentValue := GetEnvironmentVariable(KeyPair.Key);
<tr class="notcovered"><td>614<td>      SetVar := CurrentValue.Trim.IsEmpty;
<tr class="nocodegen"><td>615<td>    end;
<tr class="notcovered"><td>616<td>    if SetVar then
<tr class="nocodegen"><td>617<td>    begin
<tr class="notcovered"><td>618<td>      XPlatSetEnvironmentVariable(KeyPair.Key, KeyPair.Value);
<tr class="notcovered"><td>619<td>      Log(Format('SET: %s=%s', [KeyPair.Key, KeyPair.Value]));
<tr class="nocodegen"><td>620<td>    end
<tr class="notcovered"><td>621<td>  end;
<tr class="covered"><td>622<td>end;
<tr class="nocodegen"><td>623<td>
<tr class="nocodegen"><td>624<td>
<tr class="nocodegen"><td>625<td>procedure TDotEnv.GuardedParseDotEnvFileContents(const Contents:string);
<tr class="nocodegen"><td>626<td>type
<tr class="nocodegen"><td>627<td>  TEnvState = (StateNormal, StateKey, StateValue, StateQuotedValue, StateIgnoreRestOfLine);
<tr class="nocodegen"><td>628<td>
<tr class="nocodegen"><td>629<td>var
<tr class="nocodegen"><td>630<td>  Start, Current:PChar;
<tr class="nocodegen"><td>631<td>  State:TEnvState;
<tr class="nocodegen"><td>632<td>  Key, Value:string;
<tr class="nocodegen"><td>633<td>  WhichQuotedValue:Char;
<tr class="nocodegen"><td>634<td>  EscapePair:Boolean;
<tr class="nocodegen"><td>635<td>
<tr class="nocodegen"><td>636<td>  procedure SetNormalState;
<tr class="covered"><td>637<td>  begin
<tr class="covered"><td>638<td>    State := StateNormal;
<tr class="covered"><td>639<td>    Key := '';
<tr class="covered"><td>640<td>    Value := '';
<tr class="covered"><td>641<td>    WhichQuotedValue := #0;
<tr class="covered"><td>642<td>    Start := Current;
<tr class="covered"><td>643<td>    EscapePair := False;
<tr class="covered"><td>644<td>  end;
<tr class="nocodegen"><td>645<td>
<tr class="covered"><td>646<td>begin
<tr class="covered"><td>647<td>  if Contents = '' then
<tr class="nocodegen"><td>648<td>    Exit;
<tr class="nocodegen"><td>649<td>
<tr class="covered"><td>650<td>  Start := PChar(Contents);
<tr class="covered"><td>651<td>  Current := Start;
<tr class="covered"><td>652<td>  SetNormalState;
<tr class="covered"><td>653<td>  while Current^ &lt;&gt; #0 do
<tr class="nocodegen"><td>654<td>  begin
<tr class="covered"><td>655<td>    case State of
<tr class="nocodegen"><td>656<td>      StateNormal:
<tr class="nocodegen"><td>657<td>        begin
<tr class="covered"><td>658<td>          if CharInSet(Current^, [#10, #13, #32, #9]) then
<tr class="nocodegen"><td>659<td>          begin
<tr class="covered"><td>660<td>            Inc(Current);
<tr class="covered"><td>661<td>            Continue;
<tr class="nocodegen"><td>662<td>          end;
<tr class="covered"><td>663<td>          if Current^ = '#' then
<tr class="nocodegen"><td>664<td>          begin
<tr class="covered"><td>665<td>            State := StateIgnoreRestOfLine;
<tr class="nocodegen"><td>666<td>          end
<tr class="nocodegen"><td>667<td>          else
<tr class="nocodegen"><td>668<td>          begin
<tr class="covered"><td>669<td>            State := StateKey;
<tr class="nocodegen"><td>670<td>          end;
<tr class="nocodegen"><td>671<td>        end;
<tr class="nocodegen"><td>672<td>
<tr class="nocodegen"><td>673<td>      StateKey:
<tr class="nocodegen"><td>674<td>        begin
<tr class="covered"><td>675<td>          if (Current^ = '=') then   {//toconsider: Option to allow &quot;Key Value&quot; pairs?     or CharInSet(Current^, [#32, #9]) then}
<tr class="nocodegen"><td>676<td>          begin
<tr class="covered"><td>677<td>            Key := Copy(Start, 1, Current-Start);
<tr class="covered"><td>678<td>            State := StateValue;
<tr class="covered"><td>679<td>            Inc(Current);
<tr class="covered"><td>680<td>            Start := Current;
<tr class="nocodegen"><td>681<td>          end
<tr class="covered"><td>682<td>          else if CharInSet(Current^, [#10, #13]) then  // A key was started but no = found to set a value before end of line, so it gets ignored
<tr class="nocodegen"><td>683<td>          begin
<tr class="covered"><td>684<td>            Inc(Current);
<tr class="covered"><td>685<td>            SetNormalState;
<tr class="nocodegen"><td>686<td>          end
<tr class="nocodegen"><td>687<td>          else
<tr class="nocodegen"><td>688<td>          begin
<tr class="covered"><td>689<td>            Inc(Current);
<tr class="nocodegen"><td>690<td>          end;
<tr class="nocodegen"><td>691<td>        end;
<tr class="nocodegen"><td>692<td>
<tr class="nocodegen"><td>693<td>      StateValue:
<tr class="nocodegen"><td>694<td>        begin
<tr class="covered"><td>695<td>          if CharInSet(Current^, [TDotEnv.DoubleQuotedChar, TDotEnv.SingleQuotedChar]) then  //start quoted value
<tr class="nocodegen"><td>696<td>          begin
<tr class="covered"><td>697<td>            State := StateQuotedValue;
<tr class="covered"><td>698<td>            WhichQuotedValue := Current^;
<tr class="covered"><td>699<td>            Start := Current;
<tr class="covered"><td>700<td>            Inc(Current);
<tr class="nocodegen"><td>701<td>          end
<tr class="covered"><td>702<td>          else if CharInSet(Current^, [#10, #13]) then  //unquoted value ends with end of line characters
<tr class="nocodegen"><td>703<td>          begin
<tr class="covered"><td>704<td>            Value := Copy(Start, 1, Current-Start);
<tr class="covered"><td>705<td>            AddKeyPair(Key, Value);
<tr class="covered"><td>706<td>            Inc(Current);
<tr class="covered"><td>707<td>            SetNormalState;
<tr class="nocodegen"><td>708<td>          end
<tr class="covered"><td>709<td>          else if Current^ = '#' then  //inline comment starting, grab current unquoted value, ignore rest of line
<tr class="nocodegen"><td>710<td>          begin
<tr class="covered"><td>711<td>            Value := Copy(Start, 1, Current-Start);
<tr class="covered"><td>712<td>            AddKeyPair(Key, Value);
<tr class="covered"><td>713<td>            State := StateIgnoreRestOfLine;
<tr class="nocodegen"><td>714<td>          end
<tr class="nocodegen"><td>715<td>          else
<tr class="nocodegen"><td>716<td>          begin
<tr class="covered"><td>717<td>            Inc(Current);
<tr class="nocodegen"><td>718<td>          end;
<tr class="nocodegen"><td>719<td>        end;
<tr class="nocodegen"><td>720<td>
<tr class="nocodegen"><td>721<td>      StateQuotedValue:
<tr class="nocodegen"><td>722<td>        begin
<tr class="covered"><td>723<td>          if Current^ = WhichQuotedValue then //includes all characters (including end-of-line chars) for multi-line quoted values
<tr class="nocodegen"><td>724<td>          begin
<tr class="covered"><td>725<td>            if (WhichQuotedValue = TDotEnv.DoubleQuotedChar)
<tr class="nocodegen"><td>726<td>               and (fOptions.EnvVarOptions.EscapeSequenceInterpolationOption = TEscapeSequenceInterpolationOption.SupportEscapesInDoubleQuotedValues)
<tr class="nocodegen"><td>727<td>               and EscapePair then
<tr class="nocodegen"><td>728<td>            begin
<tr class="nocodegen"><td>729<td>              // This escaped double quote shouldn't end the value
<tr class="covered"><td>730<td>              EscapePair := False;
<tr class="covered"><td>731<td>              Inc(Current);
<tr class="nocodegen"><td>732<td>            end
<tr class="nocodegen"><td>733<td>            else
<tr class="nocodegen"><td>734<td>            begin
<tr class="covered"><td>735<td>              Value := Copy(Start, 2, Current-Start-1);
<tr class="covered"><td>736<td>              AddKeyPair(Key, Value, WhichQuotedValue);
<tr class="covered"><td>737<td>              Inc(Current);
<tr class="covered"><td>738<td>              State := StateIgnoreRestOfLine;
<tr class="nocodegen"><td>739<td>            end;
<tr class="nocodegen"><td>740<td>          end
<tr class="nocodegen"><td>741<td>          else
<tr class="nocodegen"><td>742<td>          begin
<tr class="covered"><td>743<td>            EscapePair := (not EscapePair) and (Current^ = TDotEnv.EscapeChar);
<tr class="covered"><td>744<td>            Inc(Current);
<tr class="nocodegen"><td>745<td>          end;
<tr class="nocodegen"><td>746<td>        end;
<tr class="nocodegen"><td>747<td>
<tr class="nocodegen"><td>748<td>      StateIgnoreRestOfLine:
<tr class="nocodegen"><td>749<td>        begin
<tr class="covered"><td>750<td>          Inc(Current);
<tr class="covered"><td>751<td>          if CharInSet(Current^, [#10, #13]) then
<tr class="nocodegen"><td>752<td>          begin
<tr class="covered"><td>753<td>            SetNormalState;
<tr class="nocodegen"><td>754<td>          end;
<tr class="nocodegen"><td>755<td>        end;
<tr class="nocodegen"><td>756<td>    end;
<tr class="nocodegen"><td>757<td>  end;
<tr class="nocodegen"><td>758<td>
<tr class="covered"><td>759<td>  if (not Trim(Key).IsEmpty) and (State = StateValue) then
<tr class="nocodegen"><td>760<td>  begin
<tr class="covered"><td>761<td>    AddKeyPair(Key, Start);
<tr class="nocodegen"><td>762<td>  end;
<tr class="covered"><td>763<td>end;
<tr class="nocodegen"><td>764<td>
<tr class="nocodegen"><td>765<td>
<tr class="covered"><td>766<td>initialization
<tr class="nocodegen"><td>767<td>
<tr class="covered"><td>768<td>LoadGuard := TObject.Create;
<tr class="nocodegen"><td>769<td>{$IFDEF radDotEnv_SINGLETON}
<tr class="nocodegen"><td>770<td>DotEnv := NewDotEnv;
<tr class="nocodegen"><td>771<td>{$IFEND}
<tr class="nocodegen"><td>772<td>
<tr class="covered"><td>773<td>finalization
<tr class="nocodegen"><td>774<td>
<tr class="covered"><td>775<td>LoadGuard.Free;
<tr class="nocodegen"><td>776<td>
<tr class="nocodegen"><td>777<td>
<tr class="covered"><td>778<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
